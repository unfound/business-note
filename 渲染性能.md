# 渲染性能

本页内容主要来源于[Google性能优化](https://developers.google.com/web/fundamentals/performance/why-performance-matters)

1. 注意发送的资源
   - css库(如bootstrap)是否有必要，因为css是一种阻塞渲染的资源，css框架的开销可能导致渲染延迟严重。需要视情况移除不必要的开销。
   - js库同样非常方便，但不一定是必须的。同时在选择库的时候，可以根据业务来选择尽量小的js库
   - 并非所有网站都要做成SPA，因为该类网站大量使用js，而js是最昂贵的资源。HTTP缓存配置正确或者使用Service Worker能大幅优化性能
2. 注意发送资源的方式
   - 迁移至HTTP/2
   - 使用的资源提示尽早下载资源。**rel=preload** 和 **rel=preconnect**了解下
   - 在HTTP/2下同时发送多个请求的成本更低，所以尽可能拆分代码按需加载
3. 注意发送的数据量
   - 压缩文本，js删除空格，变量替换(webpack可以做到)。SVG可以使用[SVGO](https://github.com/svg/svgo)进行优化
   - 服务器进行资源压缩，GZIP是最常用的选项，但[Brotli压缩](https://www.smashingmagazine.com/2016/10/next-generation-server-compression-with-brotli/)可以实现其他功能
   - 优化图像。时间充裕可以考虑替代图像格式，WebP以及JPEG XR了解下。提供响应式图像
   - 使用视频而不是GIF，同质量视频会小得多，通常低**80%**左右。
   - Client hints 可以根据当前网络条件和设备特性定制资源交付。 DPR、Width 和 Viewport-Width 标头可以帮助您使用服务器端代码提供适合设备的最佳图像并提供更少标记。 Save-Data 标头可以帮助您为有特定需求的用户提供负荷更轻的应用体验。（这段话需要再细细品味）
   - NetworkInformationAPI 可显示有关用户网络连接的信息。 此类信息可用于调整网速较慢用户的应用体验。

# 延迟与用户反应
|||
|---|---|
0-16ms | 人们特别擅长跟踪运动，如果动画不流畅，他们就会对运动心生反感。 用户可以感知每秒渲染 60 帧的平滑动画转场。也就是每帧 16 毫秒（包括浏览器将新帧绘制到屏幕上所需的时间），留给应用大约 10 毫秒的时间来生成一帧。
0 - 100ms | 在此时间窗口内响应用户操作，他们会觉得可以立即获得结果。时间再长，操作与反应之间的连接就会中断。
100 - 300ms | 用户会遇到轻微可觉察的延迟。
300 - 1000ms | 在此窗口内，延迟感觉像是任务自然和持续发展的一部分。对于网络上的大多数用户，加载页面或更改视图代表着一个任务。
1000+ms | 超过 1 秒，用户的注意力将离开他们正在执行的任务。
10,000+ms | 用户感到失望，可能会放弃任务；之后他们或许不会再回来。

> 了解下rail模型评估，即响应、动画、空闲、加载4个方面考虑优化


















> 一些测试工具
> 网站性能测试--[Speed Scorecard工具](https://www.thinkwithgoogle.com/feature/testmysite/),同时该网站还可以分析性能对收入的影响。